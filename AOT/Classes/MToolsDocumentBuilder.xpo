Exportfile for AOT version 1.0 or later
Formatversion: 1

***Element: CLS

; Microsoft Dynamics Class: MToolsDocumentBuilder выгружен
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #MToolsDocumentBuilder
    Id 52042
    PROPERTIES
      Name                #MToolsDocumentBuilder
      Extends             #
      RunOn               #Called from
    ENDPROPERTIES
    
    METHODS
      Version: 3
      SOURCE #bufferAppend
        #protected void bufferAppend(str _string)
        #{
        #;
        #    buffer.appendText(_string);
        #    if (maxBufferSize && buffer.size() > maxBufferSize)
        #    {
        #        this.flushBuffer();
        #    }
        #}
      ENDSOURCE
      SOURCE #checkTargetFile
        #protected boolean checkTargetFile()
        #{
        #    str fileExtention;
        #;
        #    fileExtention = conpeek(filenamesplit(target), 3);
        #    if (strupr(fileExtention) != strupr(documentFileExtension))
        #    {
        #        return checkfailed(strfmt("Расширение файла документа '%1' не соответствует требуемому ('%2')", fileExtention, documentFileExtension));
        #    }
        #    if (WinApi::fileExists(target))
        #    {
        #        return checkfailed(strfmt("Файл '%1' уже существует", target));
        #    }
        #    return true;
        #}
      ENDSOURCE
      SOURCE #checkTemplateFile
        #protected boolean checkTemplateFile()
        #{
        #;
        #    if (!WinAPI::fileExists(template))
        #    {
        #        return checkFailed(strfmt("@SYS60367", template));
        #    }
        #    return true;
        #}
      ENDSOURCE
      SOURCE #classDeclaration
        #abstract class MToolsDocumentBuilder
        #{
        #    FileName        template,
        #                    target;
        #    str             templateData;
        #    Map             templateBlocks,
        #                    templateBlockNames;
        #    int             lastBlock;
        #    TextBuffer      buffer;
        #    TextIo          textIo;
        #    int             maxBufferSize;
        #    boolean         isDocumentTemporary,
        #                    isDocumentPrepared,
        #                    isDocumentEmpty,
        #                    isDocumentReady,
        #                    isDocumentSaved,
        #                    isDocumentOpen;
        #    str             blockNameLeftQuote,
        #                    blockNameRightQuote;
        #    int             blockNameMaxLength;
        #    str             documentFileExtension;
        #
        #    #define.zeroBlockName('zero')
        #    #define.temporaryFolderName('DAXXMLSS')
        #    #define.temporaryFileLifeTime(28800)
        #}
      ENDSOURCE
      SOURCE #defaultBlockNameLeftQuote
        #abstract public str defaultBlockNameLeftQuote()
        #{
        #}
      ENDSOURCE
      SOURCE #defaultBlockNameMaxLength
        #public int defaultBlockNameMaxLength()
        #{
        #    return 20;
        #}
      ENDSOURCE
      SOURCE #defaultBlockNameRightQuote
        #abstract public str defaultBlockNameRightQuote()
        #{
        #}
      ENDSOURCE
      SOURCE #defaultDocumentFileExtension
        #abstract public str defaultDocumentFileExtension()
        #{
        #}
      ENDSOURCE
      SOURCE #defaultMaxBufferSize
        #public int defaultMaxBufferSize()
        #{
        #    return 0;
        #}
      ENDSOURCE
      SOURCE #findNameBlocks
        #protected container findNameBlocks()
        #{
        #    container ret;
        #    int scanPos;
        #    int len = strlen(templateData), blockNameLen, leftQuoteStart, leftQuoteEnd, rightQuoteStart, rightQuoteEnd;
        #    str blockName;
        #;
        #    do
        #    {
        #        scanPos ++;
        #        scanPos = strScan(templateData, blockNameLeftQuote, scanPos, len - scanPos);
        #        if (scanPos)
        #        {
        #            leftQuoteStart = scanPos;
        #            leftQuoteEnd = leftQuoteStart + strlen(blockNameLeftQuote) - 1;
        #            scanPos = strScan(templateData, blockNameRightQuote, leftQuoteEnd + 1, len - leftQuoteEnd);
        #            if (scanPos)
        #            {
        #                rightQuoteStart = scanPos;
        #                rightQuoteEnd = rightQuoteStart + strlen(blockNameRightQuote) - 1;
        #                if (leftQuoteStart && leftQuoteEnd && rightQuoteStart && rightQuoteEnd)
        #                {
        #                    blockNameLen = rightQuoteStart - leftQuoteEnd - 1;
        #                    if (blockNameLen <= blockNameMaxLength)
        #                    {
        #                        blockName = substr(templateData, leftQuoteEnd + 1, blockNameLen);
        #                        ret += [[leftQuoteStart, rightQuoteEnd, blockName]];
        #                    }
        #                }
        #            }
        #        }
        #    }
        #    while (scanPos);
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #flushBuffer
        #protected void flushBuffer()
        #{
        #;
        #    if (textIo && buffer)
        #    {
        #        textIo.writeRaw(buffer.getText());
        #        buffer.setText('');
        #    }
        #}
      ENDSOURCE
      SOURCE #getTempFile
        #protected str getTempFile()
        #{
        #    str tmpFileName, tmpFilePath;
        #;
        #    tmpFilePath = this.getTempPath();
        #    tmpFileName = guid2str(newguid());
        #    return strfmt('%1%2%3', tmpFilePath, tmpFileName, documentFileExtension);
        #}
      ENDSOURCE
      SOURCE #getTemplateBlocks
        #protected container getTemplateBlocks(container _nameBlocks)
        #{
        #    container ret;
        #    int i;
        #    int curBlockStart, curBlockEnd, nextBlockStart;
        #    str curBlockName, nextBlockName;
        #    int len = strlen(templateData);
        #
        #    void addRet()
        #    {
        #        if (curBlockStart < curBlockEnd)
        #        {
        #            ret += [[curBlockStart, curBlockEnd, curBlockName]];
        #        }
        #    }
        #;
        #    nextBlockStart = 1;
        #    nextBlockName = #zeroBlockName;
        #    for (i = 1; i <= conlen(_nameBlocks); i ++)
        #    {
        #        curBlockStart = nextBlockStart;
        #        curBlockName = nextBlockName;
        #        [curBlockEnd, nextBlockStart, nextBlockName] = conpeek(_nameBlocks, i);
        #        curBlockEnd --;
        #        nextBlockStart ++;
        #        addRet();
        #    }
        #    curBlockStart = nextBlockStart;
        #    curBlockName = nextBlockName;
        #    curBlockEnd = len;
        #    addRet();
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #getTempPath
        #protected str getTempPath()
        #{
        #    str tempDir;
        #    boolean res;
        #;
        #    tempDir = strfmt('%1%2\\', WinApi::getTempPath(), #temporaryFolderName);
        #    if (!WinApi::folderExists(tempDir))
        #    {
        #        res = WinApi::createDirectoryPath(tempDir);
        #    }
        #    else
        #    {
        #        res = true;
        #    }
        #    if (!res)
        #    {
        #        throw error(strfmt("Каталог '%1' не существует", tempDir));
        #    }
        #    return tempDir;
        #}
      ENDSOURCE
      SOURCE #initTargetFile
        #protected boolean initTargetFile()
        #{
        #    #File
        #
        #    FileIoPermission ioPermission;
        #;
        #    ioPermission = new FileIoPermission(target, #io_write);
        #    ioPermission.assert();
        #    //BP deviation documented
        #    textIo = new TextIo(target, #io_write, 65001);
        #    CodeAccessPermission::revertAssert();
        #    if (!textIo)
        #    {
        #        return checkfailed(strfmt("Невозможно открыть файл '%1' для записи", target));
        #    }
        #    return true;
        #}
      ENDSOURCE
      SOURCE #insertBlock
        #public void insertBlock(int _blockNum, container _placeHolders = connull(), container _data = connull())
        #{
        #    int placeHoldersLen = conlen(_placeHolders),
        #        dataLen = conlen(_data),
        #        len = placeHoldersLen < dataLen ? placeHoldersLen : dataLen,
        #        i;
        #    str block, placeHolder, data;
        #;
        #    if (!isDocumentPrepared)
        #    {
        #        this.prepare();
        #    }
        #    if (templateBlocks.exists(_blockNum))
        #    {
        #        if (_blockNum == 0 && !isDocumentEmpty)
        #        {
        #            throw error("Попытка вывода нулевого блока несколько раз");
        #        }
        #        if (_blockNum > 0 && isDocumentEmpty)
        #        {
        #            this.bufferAppend(templateBlocks.lookup(0));
        #            isDocumentEmpty = false;
        #        }
        #        if(_blockNum == lastBlock && isDocumentReady)
        #        {
        #            throw error("Попытка вывода после завершения построения документа");
        #        }
        #        block = templateBlocks.lookup(_blockNum);
        #        for(i = 1; i <= len; i++)
        #        {
        #            placeHolder = this.preparePlaceHolder(conpeek(_placeHolders, i));
        #            data        = this.prepareDataItem(conpeek(_data, i));
        #            block       = strReplace(block, placeHolder, data);
        #        }
        #        this.bufferAppend(block);
        #        isDocumentEmpty = false;
        #        if(_blockNum == lastBlock)
        #        {
        #            isDocumentReady = true;
        #        }
        #    }
        #    else
        #    {
        #        throw error("Заданного блока не существует");
        #    }
        #}
      ENDSOURCE
      SOURCE #insertBlockByName
        #public void insertBlockByName(str _blockName, container _placeHolders = connull(), container _data = connull())
        #{
        #    int blockNum;
        #;
        #    if (!isDocumentPrepared)
        #    {
        #        this.prepare();
        #    }
        #    if (!templateBlockNames.exists(_blockName))
        #    {
        #        throw error(strfmt("Блок '%1' не найден в шаблоне документа", _blockName));
        #    }
        #    blockNum = templateBlockNames.lookup(_blockName);
        #    this.insertBlock(blockNum, _placeHolders, _data);
        #}
      ENDSOURCE
      SOURCE #lastBlock
        #public int lastBlock()
        #{
        #    return lastBlock;
        #}
      ENDSOURCE
      SOURCE #new
        #void new(FileName _template, FileName _target = '')
        #{
        #;
        #    isDocumentTemporary = false;
        #    isDocumentPrepared  = false;
        #    isDocumentEmpty     = true;
        #    isDocumentReady     = false;
        #    isDocumentSaved     = false;
        #    isDocumentOpen      = false;
        #
        #    blockNameLeftQuote           = this.defaultBlockNameLeftQuote();
        #    blockNameRightQuote          = this.defaultBlockNameRightQuote();
        #    blockNameMaxLength           = this.defaultBlockNameMaxLength();
        #    maxBufferSize                = this.defaultMaxBufferSize();
        #    documentFileExtension        = this.defaultDocumentFileExtension();
        #
        #    buffer             = new TextBuffer();
        #    templateBlocks     = new Map(Types::Integer, Types::String);
        #    templateBlockNames = new Map(Types::String, Types::Integer);
        #
        #    template = _template;
        #    target   = _target;
        #
        #    if (!target)
        #    {
        #        isDocumentTemporary = true;
        #        target = this.getTempFile();
        #    }
        #}
      ENDSOURCE
      SOURCE #open
        #abstract void open()
        #{
        #}
      ENDSOURCE
      SOURCE #parmBlockNameLeftQuote
        #public str parmBlockNameLeftQuote(str _blockNameLeftQuote = blockNameLeftQuote)
        #{
        #    if (_blockNameLeftQuote != blockNameLeftQuote) blockNameLeftQuote = _blockNameLeftQuote;
        #
        #    return blockNameLeftQuote;
        #}
      ENDSOURCE
      SOURCE #parmBlockNameMaxLength
        #public int parmBlockNameMaxLength(int _blockNameMaxLength = blockNameMaxLength)
        #{
        #    if (_blockNameMaxLength != blockNameMaxLength) blockNameMaxLength = _blockNameMaxLength;
        #
        #    return blockNameMaxLength;
        #}
      ENDSOURCE
      SOURCE #parmBlockNameRightQuote
        #public str parmBlockNameRightQuote(str _blockNameRightQuote = blockNameRightQuote)
        #{
        #    if (_blockNameRightQuote != blockNameRightQuote) blockNameRightQuote = _blockNameRightQuote;
        #
        #    return blockNameRightQuote;
        #}
      ENDSOURCE
      SOURCE #parmDocumentFileExtension
        #public str parmDocumentFileExtension(str _documentFileExtension = documentFileExtension)
        #{
        #    if (_documentFileExtension != documentFileExtension) documentFileExtension = _documentFileExtension;
        #
        #    return documentFileExtension;
        #}
      ENDSOURCE
      SOURCE #parmMaxBufferSize
        #public int parmMaxBufferSize(int _maxBufferSize = maxBufferSize)
        #{
        #    if (_maxBufferSize != maxBufferSize) maxBufferSize = _maxBufferSize;
        #
        #    return maxBufferSize;
        #}
      ENDSOURCE
      SOURCE #prepare
        #public void prepare()
        #{
        #;
        #    if (!this.checkTemplateFile())
        #    {
        #        throw error("Невозможно загрузить шаблон документа");
        #    }
        #    if (!this.checkTargetFile())
        #    {
        #        throw error("Невозможно создать файл документа");
        #    }
        #    if (isDocumentTemporary)
        #    {
        #        this.tempCleanup();
        #    }
        #    if (!this.initTargetFile())
        #    {
        #        throw error("Невозможно создать файл документа");
        #    }
        #    if (!this.readTemplate())
        #    {
        #        throw error("Невозможно разобрать шаблон документа");
        #    }
        #    isDocumentPrepared = true;
        #}
      ENDSOURCE
      SOURCE #prepareDataItem
        #protected str prepareDataItem(anytype _dataItem)
        #{
        #    return _dataItem;
        #}
      ENDSOURCE
      SOURCE #preparePlaceHolder
        #protected str preparePlaceHolder(anytype _placeHolder)
        #{
        #    return _placeHolder;
        #}
      ENDSOURCE
      SOURCE #prepareTemplate
        #protected void prepareTemplate()
        #{
        #}
      ENDSOURCE
      SOURCE #readTemplate
        #protected boolean readTemplate()
        #{
        #    container nameBlocks, tmplBlocks;
        #;
        #    this.readTemplateFile();
        #    this.prepareTemplate();
        #    nameBlocks = this.findNameBlocks();
        #    tmplBlocks = this.getTemplateBlocks(nameBlocks);
        #    this.readTemplateBlocks(tmplBlocks);
        #
        #    if (templateBlocks.elements() <= 2)
        #    {
        #        return checkfailed("В шаблоне документа должно быть более двух блоков");
        #    }
        #    return true;
        #}
      ENDSOURCE
      SOURCE #readTemplateBlocks
        #protected void readTemplateBlocks(container _templateBlocks)
        #{
        #    int i;
        #    int blockStart, blockEnd;
        #    str blockName;
        #;
        #    lastBlock = -1;
        #    for (i = 1; i <= conlen(_templateBlocks); i ++)
        #    {
        #        lastBlock ++;
        #        [blockStart, blockEnd, blockName] = conpeek(_templateBlocks, i);
        #        templateBlocks.insert(i - 1, subStr(templateData, blockStart, blockEnd - blockStart + 1));
        #        templateBlockNames.insert(blockName, lastBlock);
        #    }
        #}
      ENDSOURCE
      SOURCE #readTemplateFile
        #protected void readTemplateFile()
        #{
        #    #CLRInterop
        #
        #    InteropPermission permission;
        #    System.IO.FileStream fileStream;
        #    System.IO.StreamReader streamReader;
        #    System.Text.UTF8Encoding utf8Encoding;
        #    CLRObject fileMode, fileAccess, fileShare, clrException;
        #;
        #    permission = new InteropPermission(InteropKind::ClrInterop);
        #    permission.assert();
        #    try
        #    {
        #        //BP deviation documented
        #        utf8Encoding = new System.Text.UTF8Encoding();
        #        fileMode   = ClrInterop::parseClrEnum(#Enum_SystemIOFileMode_Open);
        #        fileAccess = ClrInterop::parseClrEnum(#Enum_SystemIOFileAccess_Read);
        #        fileShare  = ClrInterop::parseClrEnum(#Enum_SystemIOFileShare_ReadWrite);
        #        //BP deviation documented
        #        fileStream = new ClrObject(#Class_SystemIOFileStream, template, fileMode, fileAccess, fileShare);
        #        //BP deviation documented
        #        streamReader = new System.IO.StreamReader(fileStream, utf8Encoding);
        #        templateData = streamReader.ReadToEnd();
        #        streamReader.Close();
        #    }
        #    catch (Exception::Internal)
        #    {
        #        //BP deviation documented
        #        clrException = CLRInterop::getLastException();
        #        throw error(getCLRExceprionText(clrException));
        #    }
        #    catch (Exception::CLRError)
        #    {
        #        //BP deviation documented
        #        clrException = CLRInterop::getLastException();
        #        throw error(getCLRExceprionText(clrException));
        #    }
        #    CodeAccessPermission::revertAssert();
        #}
      ENDSOURCE
      SOURCE #save
        #abstract void save()
        #{
        #}
      ENDSOURCE
      SOURCE #saveDocumentFile
        #public void saveDocumentFile()
        #{
        #;
        #    if (isDocumentEmpty)
        #    {
        #        this.insertBlock(0);
        #    }
        #    if (!isDocumentReady)
        #    {
        #        this.insertBlock(lastBlock);
        #    }
        #    this.flushBuffer();
        #    textIo = null;
        #    isDocumentSaved = true;
        #}
      ENDSOURCE
      SOURCE #show
        #abstract void show()
        #{
        #}
      ENDSOURCE
      SOURCE #tempCleanup
        #protected void tempCleanup()
        #{
        #    #define.tempCleanupMask('*.*')
        #    #WinApi
        #
        #    FilePath    filePath;
        #    FileName    fileName;
        #    int         fileHandle, attrs;
        #    container   fileInfo;
        #
        #    void processFile(str _file)
        #    {
        #        date        createDate;
        #        timeofday   createTime;
        #        int64       difference;
        #        int         res;
        #    ;
        #        [createDate, createTime] = MToolsDocumentBuilder::getFileTimeLocal(_file);
        #        difference = MToolsDocumentBuilder::getDateTimeDifference(createDate, createTime, today(), timenow());
        #        if (difference >= #temporaryFileLifetime)
        #        {
        #            res = WinApi::deleteFile(_file);
        #            if (res)
        #            {
        #                warning(strfmt("Не удаётся удалить временный файл '%1'", _file));
        #            }
        #        }
        #    }
        #;
        #    filePath   = this.getTempPath();
        #    fileInfo   = WinApi::findFirstFile(filePath + #tempCleanupMask);
        #    fileHandle = conpeek(fileInfo,1);
        #    fileName   = conpeek(fileInfo, 2);
        #    while (fileName != '')
        #    {
        #        if(fileName != '..' && fileName != '.')
        #        {
        #            attrs = WinApi::getFileAttributes(filePath + fileName);
        #            if(!(attrs & #FILE_ATTRIBUTE_DIRECTORY))
        #            {
        #               processFile(filePath + fileName);
        #            }
        #        }
        #        fileName = WinApi::findNextFile(fileHandle);
        #    }
        #}
      ENDSOURCE
      SOURCE #getDateTimeDifference
        #public static int64 getDateTimeDifference(date _dateFrom, timeOfDay _timeFrom, date _dateTo, timeOfDay _timeTo)
        #{
        #    int64 ret;
        #;
        #    ret = (_dateTo - _dateFrom) * 86400;
        #    ret += _timeTo - _timeFrom;
        #    return ret;
        #}
      ENDSOURCE
      SOURCE #getFileTimeLocal
        #public client static container getFileTimeLocal(Filename filename, int type = 0)
        #{
        #    #WinApi
        #
        #    int       hFile       = WinAPI::createFile(filename, #OPEN_EXISTING);
        #    Binary    filetime;
        #    Binary    systemTime;
        #    Binary    localTime;
        #;
        #    if (hFile)
        #    {
        #        filetime    = WinAPI::getFileTime(hFile, type);
        #        WinAPI::closeHandle(hFile);
        #        if (filetime)
        #        {
        #            systemTime  = WinAPI::fileTimeToSystemTime(filetime);
        #            localTime   = WinAPI::systemTimeToTzSpecificLocalTime(systemTime);
        #
        #            if (localTime)
        #            {
        #                return [WinAPI::systemTimeToDate(localTime), WinAPI::systemTimeToTimeOfDay(localTime)];
        #            }
        #        }
        #    }
        #    return connull();
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: END
